# name: test/sql/faiss_basic.test
# description: Test basic FAISS index functionality (Flat, HNSW, IVFFlat)
# group: [faiss]

require ann

# ========================================
# Flat index (default)
# ========================================

statement ok
CREATE TABLE vectors (id INT, embedding FLOAT[3]);

statement ok
INSERT INTO vectors VALUES
  (1, [1.0, 0.0, 0.0]),
  (2, [0.0, 1.0, 0.0]),
  (3, [0.0, 0.0, 1.0]);

statement ok
CREATE INDEX flat_idx ON vectors USING FAISS (embedding);

# Verify index exists
query I
SELECT count(*) FROM duckdb_indexes() WHERE index_name = 'flat_idx';
----
1

# Verify it shows up in ann_list
query III
SELECT * FROM ann_list() WHERE name = 'flat_idx';
----
flat_idx	FAISS	vectors

# Search nearest to [1,0,0] via raw index scan
query II
SELECT row_id, distance FROM faiss_index_scan('vectors', 'flat_idx', [1.0, 0.0, 0.0], 2) ORDER BY distance;
----
0	0.0
1	2.0

# Search via unified ann_search (returns full rows)
query III
SELECT id, embedding, _distance
FROM ann_search('vectors', 'flat_idx', [1.0, 0.0, 0.0]::FLOAT[3], 3)
ORDER BY _distance;
----
1	[1.0, 0.0, 0.0]	0.0
2	[0.0, 1.0, 0.0]	2.0
3	[0.0, 0.0, 1.0]	2.0

# Insert and search again
statement ok
INSERT INTO vectors VALUES (4, [0.9, 0.1, 0.0]);

query II
SELECT v.id, s.distance
FROM faiss_index_scan('vectors', 'flat_idx', [1.0, 0.0, 0.0], 2) s
JOIN vectors v ON v.rowid = s.row_id
ORDER BY s.distance;
----
1	0.0
4	0.020000001

# Drop index
statement ok
DROP INDEX flat_idx;

query I
SELECT count(*) FROM duckdb_indexes() WHERE index_name = 'flat_idx';
----
0

# ========================================
# HNSW index
# ========================================

statement ok
CREATE INDEX hnsw_idx ON vectors USING FAISS (embedding) WITH (type = 'HNSW', hnsw_m = 16);

query I
SELECT count(*) FROM duckdb_indexes() WHERE index_name = 'hnsw_idx';
----
1

# HNSW should find nearest neighbor
query II
SELECT v.id, s.distance
FROM faiss_index_scan('vectors', 'hnsw_idx', [1.0, 0.0, 0.0], 1) s
JOIN vectors v ON v.rowid = s.row_id;
----
1	0.0

statement ok
DROP INDEX hnsw_idx;

# ========================================
# Inner Product metric
# ========================================

statement ok
CREATE INDEX ip_idx ON vectors USING FAISS (embedding) WITH (metric = 'IP');

# Inner product: [1,0,0] dot [1,0,0] = 1.0 (highest similarity)
query II
SELECT v.id, s.distance
FROM faiss_index_scan('vectors', 'ip_idx', [1.0, 0.0, 0.0], 1) s
JOIN vectors v ON v.rowid = s.row_id;
----
1	1.0

statement ok
DROP INDEX ip_idx;

# ========================================
# Delete: tombstones exclude rows
# ========================================

statement ok
CREATE INDEX del_idx ON vectors USING FAISS (embedding);

# Before delete: id=1 is nearest
query II
SELECT v.id, s.distance
FROM faiss_index_scan('vectors', 'del_idx', [1.0, 0.0, 0.0], 1) s
JOIN vectors v ON v.rowid = s.row_id;
----
1	0.0

# Delete the nearest vector
statement ok
DELETE FROM vectors WHERE id = 1;

# After delete: next nearest should be returned
query II
SELECT v.id, s.distance
FROM faiss_index_scan('vectors', 'del_idx', [1.0, 0.0, 0.0], 1) s
JOIN vectors v ON v.rowid = s.row_id;
----
4	0.020000001

statement ok
DROP INDEX del_idx;

# ========================================
# Vacuum: compacts deleted vectors
# ========================================

statement ok
CREATE TABLE vac_vectors (id INT, embedding FLOAT[3]);

statement ok
INSERT INTO vac_vectors VALUES
  (1, [1.0, 0.0, 0.0]),
  (2, [0.0, 1.0, 0.0]),
  (3, [0.0, 0.0, 1.0]),
  (4, [0.9, 0.1, 0.0]),
  (5, [0.0, 0.9, 0.1]);

statement ok
CREATE INDEX vac_idx ON vac_vectors USING FAISS (embedding);

# Verify 5 vectors indexed
query I
SELECT num_vectors FROM ann_index_info() WHERE name = 'vac_idx';
----
5

# Delete two vectors
statement ok
DELETE FROM vac_vectors WHERE id IN (2, 3);

# Search still works after delete (tombstones)
query II
SELECT v.id, s.distance
FROM faiss_index_scan('vac_vectors', 'vac_idx', [1.0, 0.0, 0.0], 2) s
JOIN vac_vectors v ON v.rowid = s.row_id
ORDER BY s.distance;
----
1	0.0
4	0.020000001

# Run VACUUM to compact
statement ok
VACUUM vac_vectors;

# After vacuum: vector count should drop to 3
query I
SELECT num_vectors FROM ann_index_info() WHERE name = 'vac_idx';
----
3

# Search still returns correct results after vacuum
query II
SELECT v.id, s.distance
FROM faiss_index_scan('vac_vectors', 'vac_idx', [1.0, 0.0, 0.0], 2) s
JOIN vac_vectors v ON v.rowid = s.row_id
ORDER BY s.distance;
----
1	0.0
4	0.020000001

# Deleted count should be 0 after vacuum
query I
SELECT num_deleted FROM ann_index_info() WHERE name = 'vac_idx';
----
0

statement ok
DROP INDEX vac_idx;

statement ok
DROP TABLE vac_vectors;

# ========================================
# MergeIndexes: post-creation inserts are merged
# ========================================

statement ok
CREATE TABLE merge_vectors (id INT, embedding FLOAT[3]);

statement ok
INSERT INTO merge_vectors VALUES
  (1, [1.0, 0.0, 0.0]),
  (2, [0.0, 1.0, 0.0]);

statement ok
CREATE INDEX merge_idx ON merge_vectors USING FAISS (embedding);

# Insert more rows after index creation (triggers MergeIndexes)
statement ok
INSERT INTO merge_vectors VALUES
  (3, [0.0, 0.0, 1.0]),
  (4, [0.9, 0.1, 0.0]);

# All 4 vectors should be searchable
query I
SELECT count(*) FROM faiss_index_scan('merge_vectors', 'merge_idx', [1.0, 0.0, 0.0], 4);
----
4

# Nearest to [1,0,0] should be id=1, then id=4
query II
SELECT v.id, s.distance
FROM faiss_index_scan('merge_vectors', 'merge_idx', [1.0, 0.0, 0.0], 2) s
JOIN merge_vectors v ON v.rowid = s.row_id
ORDER BY s.distance;
----
1	0.0
4	0.020000001

statement ok
DROP INDEX merge_idx;

statement ok
DROP TABLE merge_vectors;

# ========================================
# Error: wrong dimension query
# ========================================

statement ok
CREATE INDEX err_idx ON vectors USING FAISS (embedding);

# Query with wrong dimension returns empty (dimension mismatch handled gracefully)
query I
SELECT count(*) FROM faiss_index_scan('vectors', 'err_idx', [1.0, 0.0], 2);
----
0

statement ok
DROP INDEX err_idx;

# Clean up
statement ok
DROP TABLE vectors;
