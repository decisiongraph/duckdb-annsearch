# name: test/sql/diskann_metric_ip.test
# description: Test DiskANN with inner product metric
# group: [diskann]

require ann

statement ok
CREATE TABLE vecs (id INT, embedding FLOAT[3]);

statement ok
INSERT INTO vecs VALUES
  (1, [1.0, 0.0, 0.0]),
  (2, [0.0, 1.0, 0.0]),
  (3, [0.0, 0.0, 1.0]),
  (4, [0.7, 0.7, 0.0]);

# ========================================
# Inner product metric
# ========================================

statement ok
CREATE INDEX ip_idx ON vecs USING DISKANN (embedding) WITH (metric = 'IP');

query I
SELECT count(*) FROM duckdb_indexes() WHERE index_name = 'ip_idx';
----
1

# Nearest to [1,0,0] by inner product:
# ip(1,0,0 . 1,0,0) = 1.0, ip(1,0,0 . 0.7,0.7,0) = 0.7, etc.
# DiskANN returns squared L2 distance for IP metric too (implementation detail)
# Just verify nearest neighbor is id=1
query I
SELECT v.id
FROM diskann_index_scan('vecs', 'ip_idx', [1.0, 0.0, 0.0], 1) s
JOIN vecs v ON v.rowid = s.row_id;
----
1

# ann_search also works with IP index
query I
SELECT id
FROM ann_search('vecs', 'ip_idx', [1.0, 0.0, 0.0]::FLOAT[3], 1);
----
1

# Insert and search again
statement ok
INSERT INTO vecs VALUES (5, [0.95, 0.05, 0.0]);

query I
SELECT v.id
FROM diskann_index_scan('vecs', 'ip_idx', [1.0, 0.0, 0.0], 2) s
JOIN vecs v ON v.rowid = s.row_id
ORDER BY s.distance
LIMIT 2;
----
1
5

# ========================================
# IP metric persistence
# ========================================

load __TEST_DIR__/diskann_ip_persist.db

statement ok
CREATE TABLE pvecs (id INT, embedding FLOAT[3]);

statement ok
INSERT INTO pvecs VALUES
  (1, [1.0, 0.0, 0.0]),
  (2, [0.0, 1.0, 0.0]),
  (3, [0.5, 0.5, 0.0]);

statement ok
CREATE INDEX ip_persist ON pvecs USING DISKANN (embedding) WITH (metric = 'IP');

statement ok
CHECKPOINT;

restart

query I
SELECT v.id
FROM diskann_index_scan('pvecs', 'ip_persist', [1.0, 0.0, 0.0], 1) s
JOIN pvecs v ON v.rowid = s.row_id;
----
1

statement ok
DROP TABLE pvecs;
